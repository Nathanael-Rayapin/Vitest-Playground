# ğŸ“¦ Quâ€™est-ce quâ€™un module en JavaScript (et dans Vitest) ?

Avant de parler de **mock de module**, il est essentiel de bien comprendre ce quâ€™est un **module**.

## ğŸ”¹ DÃ©finition simple

En JavaScript (et donc dans Vitest) :

> **Un module est simplement un fichier qui exporte quelque chose.**

Cela peut Ãªtre :

* une fonction
* une variable
* une constante
* une classe
* ou plusieurs exports Ã  la fois

ğŸ‘‰ **Chaque fichier qui contient un `export` est un module.**

## ğŸ”¹ Exemple de module

### `example.js`

```js
export function answer() {
  return 42
}

export const variable = 'example'
```

â¡ï¸ Ce fichier est un **module**, car il exporte :

* une fonction `answer`
* une constante `variable`

---

## ğŸ”¹ Le "module object" (objet de module)

Quand on importe **tout le module dâ€™un coup**, on obtient ce quâ€™on appelle un **module object**.

### Import du module entier

```js
import * as exampleObject from './example.js'
```

`exampleObject` est un **objet namespace** qui contient **tous les exports du module** :

```js
exampleObject.answer   // function
exampleObject.variable // 'example'
```

ğŸ‘‰ On peut le voir comme :

```js
{
  answer: [Function],
  variable: 'example'
}
```

## ğŸ”¹ Import nommÃ© â‰  absence de module object

MÃªme si tu fais un import nommÃ© :

```js
import { answer, variable } from './example.js'
```

ğŸ‘‰ **Le module object existe quand mÃªme en interne**.

La diffÃ©rence est simplement :

* tu ne le manipules pas directement
* le bundler / runtime le gÃ¨re pour toi

Vitest (et les outils de mock) peuvent **toujours rÃ©fÃ©rencer ce module object**.

## ğŸ”¹ Pourquoi câ€™est important pour Vitest ?

Vitest **mocke des modules**, pas des fonctions isolÃ©es.

Quand tu Ã©cris :

```js
vi.mock('./example.js')
```

ğŸ‘‰ Vitest :

* intercepte le **module object**
* remplace ses exports (`answer`, `variable`, etc.)
* redirige tous les imports vers la version mockÃ©e

Câ€™est pour cela que :

* les mocks doivent Ãªtre dÃ©finis **au niveau du module**
* tu ne peux pas mocker un export depuis lâ€™intÃ©rieur du fichier lui-mÃªme

## ğŸ”¹ OÃ¹ peut-on accÃ©der au module object ?

âŒ **Impossible depuis le module lui-mÃªme**

```js
// example.js âŒ
exampleObject.answer = ...
```

âœ”ï¸ **Possible depuis lâ€™extÃ©rieur**, par exemple dans un test :

```js
import * as exampleObject from './example.js'

// ici, exampleObject est accessible
```

ğŸ‘‰ Câ€™est **exactement pour Ã§a** que les mocks se font :

* dans les fichiers de test
* ou dans des fichiers dÃ©diÃ©s aux mocks

## ğŸ§  RÃ©sumÃ© mental

* ğŸ“„ **Un module = un fichier avec des exports**
* ğŸ“¦ **Le module object = lâ€™objet qui contient tous les exports**
* ğŸ”— `import * as module` donne accÃ¨s Ã  cet objet
* ğŸ§ª Vitest mocke **le module object**, pas juste une fonction
* ğŸš« Un module ne peut pas se modifier lui-mÃªme

## âœ… Pourquoi cette notion est cruciale ?

Comprendre Ã§a permet de :

* maÃ®triser `vi.mock`
* comprendre pourquoi les mocks sont globaux
* Ã©viter les erreurs de portÃ©e
* Ã©crire des tests plus fiables et plus lisibles